#!/usr/bin/env node
/* vim: set syntax=javascript ft=javascript : */
const Promise = require('bluebird'),
      request = require('request-promise'),
      flatten = require('flat'),
      fs = require('fs'),
      lib = require('../lib');

function getMixesOfInterest(tags, page=1) {
  return request({
    method: 'GET',
    url: `https://8tracks.com/explore/${tags.join('+')}/hot/${page}?include=pagination%2Cmixes&format=jsonh`,
  }).then(body => {
    const data = JSON.parse(body).mix_set.mixes;
    return data.map(mix => mix.id);
  });
}

// Use this script interactively:
if (require.main === module) {
  const argv = require('minimist')(process.argv.slice(2));

  // Use the specified set id, or generate a random set id from 100k-400k
  let set = lib.generateRandomSetId();

  const artist = argv.artist ? new RegExp(argv.artist, 'i') : null;
  const album = argv.album ? new RegExp(argv.album, 'i') : null;
  const name = argv.name ? new RegExp(argv.name, 'i') : null;

  if ((!artist && !album) || argv.help) {
    console.error(`Usage: ./8tracks-find-artist [--artist foo] [--album bar] [--delay]`);
    console.error(`--artist specifies a given artist to search for. It's a case insensitive regex.`);
    console.error(`--album specifies a given album to search for. It's a case insensitive regex.`);
    console.error(`--delay specifies whether to wait the length of each track after the track is
        fetched as if it was "playing". For longer playlists, 8tracks can't handle fetching all
        songs at once, so this is a way around that. Unfortunately, this means that fetching a
        playlist with this flag takes as long as it takes for the playlist to play to its end :(`);
    console.error(`--pages specifies how many pages of mixes to searhc through. By default, it's 10.`);
    console.error(`Error: please specify a mix id to fetch with --mix (it's a required argument)`);
    process.exit(1);
  }

  const tags = [argv.artist, argv.album].filter(i => i);

  // Get mixes across a range of pages.
  const mixPages = [];
  for (let i = 0; i < (argv.pages || 10); i++) {
    mixPages.push(getMixesOfInterest(tags, i));
  }

  return Promise.all(mixPages).then(mixesOnEachPage => {
    const mixes = mixesOnEachPage.reduce((acc, i) => [...acc, ...i], []);

    console.log('%TRACKINFO');
    console.log(`name: Find Artist Playlist`);

    const tracksThatMatch = [];
    const all = mixes.map(mixId => {
      // For each mix, get all tracks within.
      const setId = lib.generateRandomSetId();
      const {emitter, complete} = lib.getTracksInMix(mixId, setId, {delayLengthOfTrack: argv.delay || false});

      // For each track that is received...
      emitter.on('track', track => {
        if (
          // Make sure the track matches all the filters that were specified
          (!artist || track.artist_details.name.match(artist)) &&
          (!album || track.release_name.match(album)) &&
          (!name || track.name.match(name)) &&

          // Only add new unique tracks
          (tracksThatMatch.find(i => i.name.trim(' ') === track.name.trim(' ')) !== null)
        ) {
          lib.logTrack(track);
        }
      });

      // FIXME: this is a bad idea maybe?
      return complete.catch(e => null);
    });

    return Promise.all(all).catch(err => console.error(err));
  });
}
